<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Stringx (stringx.Stringx)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">stringx</a> &#x00BB; Stringx</nav><header class="odoc-preamble"><h1>Module <code><span>Stringx</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-Levenshtein"><a href="#module-Levenshtein" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Levenshtein/index.html">Levenshtein</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-center"><a href="#val-center" class="anchor"></a><code><span><span class="keyword">val</span> center : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>center s len pad</code> centers <code>s</code> in a string of length <code>len</code>, padding with <code>pad</code>. If <code>s</code> is longer than <code>len</code>, it is returned unchanged. Padding is inserted symmetrically. <code>pad</code> must be non-empty or it is ignored.</p><p>This function is Unicode-aware and counts characters, not bytes. If <code>pad</code> is multibyte, it is repeated and truncated as needed.</p><p>Examples:</p><ul><li><code>center &quot;hello&quot; 10 &quot; &quot;</code> returns <code>&quot;  hello   &quot;</code></li><li><code>center &quot;abc&quot; 7 &quot;あ&quot;</code> returns <code>&quot;ああabcああ&quot;</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The string to center (UTF-8)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">len</span> <p>The total length (in Unicode characters) of the result</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pad</span> <p>The padding string (UTF-8, non-empty)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The centered string</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-count"><a href="#val-count" class="anchor"></a><code><span><span class="keyword">val</span> count : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>count str pattern</code> counts how many Unicode characters in <code>str</code> match <code>pattern</code>.</p><p>The <code>pattern</code> supports:</p><ul><li>character sets: e.g., &quot;aeiou&quot;</li><li>ranges: e.g., &quot;a-k&quot;, &quot;あ-ん&quot;</li><li>negation with ^: e.g., &quot;^a-k&quot;, &quot;^0-9&quot;</li></ul><p>This function is Unicode-aware and handles UTF-8 properly.</p><p>Examples:</p><ul><li><code>count &quot;hello&quot; &quot;aeiou&quot;</code> returns <code>2</code></li><li><code>count &quot;abc123&quot; &quot;^a-z&quot;</code> returns <code>3</code></li><li><code>count &quot;こんにちは&quot; &quot;あ-ん&quot;</code> returns <code>5</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">str</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pattern</span> <p>The character pattern (see above)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The number of matching characters</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-delete"><a href="#val-delete" class="anchor"></a><code><span><span class="keyword">val</span> delete : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>delete str pattern</code> removes all Unicode characters in <code>str</code> that match <code>pattern</code>.</p><p>The <code>pattern</code> supports:</p><ul><li>character sets: e.g., &quot;aeiou&quot;</li><li>ranges: e.g., &quot;a-k&quot;, &quot;あ-ん&quot;</li><li>negation with ^: e.g., &quot;^a-k&quot;, &quot;^0-9&quot;</li></ul><p>This function is Unicode-aware and handles UTF-8 properly.</p><p>Examples:</p><ul><li><code>delete &quot;hello&quot; &quot;aeiou&quot;</code> returns <code>&quot;hll&quot;</code></li><li><code>delete &quot;こんにちは&quot; &quot;こ&quot;</code> returns <code>&quot;んにちは&quot;</code></li><li><code>delete &quot;abc123&quot; &quot;^a-z&quot;</code> returns <code>&quot;abc&quot;</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">str</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pattern</span> <p>The character pattern (see above)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The string with matched characters removed</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-len"><a href="#val-len" class="anchor"></a><code><span><span class="keyword">val</span> len : <span>string <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>len str</code> returns the number of Unicode code points (runes) in UTF-8 string <code>str</code>.</p><p>This function is Unicode-aware and counts characters, not bytes.</p><p>Examples:</p><ul><li><code>len &quot;hello&quot;</code> returns <code>5</code></li><li><code>len &quot;こんにちは&quot;</code> returns <code>5</code></li><li><code>len &quot;🍎🍏🍊&quot;</code> returns <code>3</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">str</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The number of Unicode code points in <code>str</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reverse"><a href="#val-reverse" class="anchor"></a><code><span><span class="keyword">val</span> reverse : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>reverse s</code> reverses a UTF-8 encoded string <code>s</code>.</p><p>This function is Unicode-aware and reverses by code points, not bytes.</p><p>Examples:</p><ul><li><code>reverse &quot;hello&quot;</code> returns <code>&quot;olleh&quot;</code></li><li><code>reverse &quot;こんにちは&quot;</code> returns <code>&quot;はちにんこ&quot;</code></li><li><code>reverse &quot;🍎🍏🍊&quot;</code> returns <code>&quot;🍊🍏🍎&quot;</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The reversed string</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-contains"><a href="#val-contains" class="anchor"></a><code><span><span class="keyword">val</span> contains : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>contains s substr</code> reports whether <code>substr</code> is within <code>s</code>.</p><p>Returns <code>true</code> if <code>substr</code> is the empty string, or if <code>substr</code> occurs anywhere in <code>s</code>. Returns <code>false</code> otherwise.</p><p>This function is Unicode-agnostic and operates on bytes, not code points.</p><p>Examples:</p><ul><li><code>contains &quot;seafood&quot; &quot;foo&quot;</code> returns <code>true</code></li><li><code>contains &quot;seafood&quot; &quot;bar&quot;</code> returns <code>false</code></li><li><code>contains &quot;seafood&quot; &quot;&quot;</code> returns <code>true</code></li><li><code>contains &quot;&quot; &quot;&quot;</code> returns <code>true</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">substr</span> <p>The substring to search for</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>true</code> if <code>substr</code> is found in <code>s</code>, <code>false</code> otherwise</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-contains_any"><a href="#val-contains_any" class="anchor"></a><code><span><span class="keyword">val</span> contains_any : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>contains_any s chars</code> reports whether any Unicode code points in <code>chars</code> are within <code>s</code>.</p><p>Returns <code>false</code> if <code>chars</code> is empty. Unicode-aware and compares by code points.</p><p>Examples:</p><ul><li><code>contains_any &quot;team&quot; &quot;i&quot;</code> returns <code>false</code></li><li><code>contains_any &quot;fail&quot; &quot;ui&quot;</code> returns <code>true</code></li><li><code>contains_any &quot;ure&quot; &quot;ui&quot;</code> returns <code>true</code></li><li><code>contains_any &quot;failure&quot; &quot;ui&quot;</code> returns <code>true</code></li><li><code>contains_any &quot;foo&quot; &quot;&quot;</code> returns <code>false</code></li><li><code>contains_any &quot;&quot; &quot;&quot;</code> returns <code>false</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">chars</span> <p>The set of Unicode code points to search for (UTF-8)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>true</code> if any code point in <code>chars</code> is found in <code>s</code>, <code>false</code> otherwise</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-has_prefix"><a href="#val-has_prefix" class="anchor"></a><code><span><span class="keyword">val</span> has_prefix : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>has_prefix s prefix</code> reports whether the string <code>s</code> begins with <code>prefix</code>.</p><p>Returns <code>true</code> if <code>prefix</code> is the empty string, or if <code>s</code> starts with <code>prefix</code>. Returns <code>false</code> otherwise.</p><p>This function is Unicode-agnostic and operates on bytes, not code points.</p><p>Examples:</p><ul><li><code>has_prefix &quot;Gopher&quot; &quot;Go&quot;</code> returns <code>true</code></li><li><code>has_prefix &quot;Gopher&quot; &quot;C&quot;</code> returns <code>false</code></li><li><code>has_prefix &quot;Gopher&quot; &quot;&quot;</code> returns <code>true</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">prefix</span> <p>The prefix to test</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>true</code> if <code>s</code> starts with <code>prefix</code>, <code>false</code> otherwise</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-has_suffix"><a href="#val-has_suffix" class="anchor"></a><code><span><span class="keyword">val</span> has_suffix : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>has_suffix s suffix</code> reports whether the string <code>s</code> ends with <code>suffix</code>.</p><p>Returns <code>true</code> if <code>suffix</code> is the empty string, or if <code>s</code> ends with <code>suffix</code>. Returns <code>false</code> otherwise.</p><p>This function is Unicode-agnostic and operates on bytes, not code points.</p><p>Examples:</p><ul><li><code>has_suffix &quot;Amigo&quot; &quot;go&quot;</code> returns <code>true</code></li><li><code>has_suffix &quot;Amigo&quot; &quot;O&quot;</code> returns <code>false</code></li><li><code>has_suffix &quot;Amigo&quot; &quot;Ami&quot;</code> returns <code>false</code></li><li><code>has_suffix &quot;Amigo&quot; &quot;&quot;</code> returns <code>true</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">suffix</span> <p>The suffix to test</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>true</code> if <code>s</code> ends with <code>suffix</code>, <code>false</code> otherwise</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-count_substring"><a href="#val-count_substring" class="anchor"></a><code><span><span class="keyword">val</span> count_substring : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>count_substring s substr</code> counts the number of non-overlapping instances of <code>substr</code> in <code>s</code>.</p><p>If <code>substr</code> is the empty string, returns 1 + the number of Unicode code points in <code>s</code>.</p><p>This function is Unicode-agnostic and operates on bytes, not code points.</p><p>Examples:</p><ul><li><code>count_substring &quot;cheese&quot; &quot;e&quot;</code> returns <code>3</code></li><li><code>count_substring &quot;five&quot; &quot;&quot;</code> returns <code>5</code></li><li><code>count_substring &quot;banana&quot; &quot;na&quot;</code> returns <code>2</code></li><li><code>count_substring &quot;aaaaa&quot; &quot;aa&quot;</code> returns <code>2</code></li><li><code>count_substring &quot;&quot; &quot;&quot;</code> returns <code>1</code></li><li><code>count_substring &quot;&quot; &quot;a&quot;</code> returns <code>0</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">substr</span> <p>The substring to count</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The number of non-overlapping instances of <code>substr</code> in <code>s</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_fold"><a href="#val-equal_fold" class="anchor"></a><code><span><span class="keyword">val</span> equal_fold : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal_fold s t</code> reports whether <code>s</code> and <code>t</code>, interpreted as UTF-8 strings, are equal under simple Unicode case-folding (ASCII only).</p><p>This is a simple case-insensitive comparison for ASCII letters only. (It does not perform full Unicode case folding.)</p><p>Examples:</p><ul><li><code>equal_fold &quot;Go&quot; &quot;go&quot;</code> returns <code>true</code></li><li><code>equal_fold &quot;AB&quot; &quot;ab&quot;</code> returns <code>true</code></li><li><code>equal_fold &quot;ß&quot; &quot;ss&quot;</code> returns <code>false</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The first string (UTF-8)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">t</span> <p>The second string (UTF-8)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>true</code> if <code>s</code> and <code>t</code> are equal under simple case folding, <code>false</code> otherwise</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fields"><a href="#val-fields" class="anchor"></a><code><span><span class="keyword">val</span> fields : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>fields s</code> splits the string <code>s</code> around each instance of one or more consecutive Unicode whitespace characters, returning a list of substrings of <code>s</code> or an empty list if <code>s</code> contains only whitespace.</p><p>Whitespace is defined by Unicode (see <code>is_space</code>).</p><p>Examples:</p><ul><li><code>fields &quot;  foo bar  baz   &quot;</code> returns <code>[&quot;foo&quot;; &quot;bar&quot;; &quot;baz&quot;]</code></li><li><code>fields &quot;   &quot;</code> returns <code>[]</code></li><li><code>fields &quot;a\tb\nc&quot;</code> returns <code>[&quot;a&quot;; &quot;b&quot;; &quot;c&quot;]</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>List of non-whitespace substrings of <code>s</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fields_func"><a href="#val-fields_func" class="anchor"></a><code><span><span class="keyword">val</span> fields_func : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Uchar.t <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>fields_func s f</code> splits the string <code>s</code> at each run of Unicode code points <code>c</code> satisfying <code>f c</code>, returning a list of substrings of <code>s</code> or an empty list if all code points in <code>s</code> satisfy <code>f</code> or <code>s</code> is empty.</p><p>Examples:</p><ul><li><code>fields_func &quot;  foo1;bar2,baz3...&quot; (fun c -&gt; not (is_letter c || is_number c))</code> returns <code>[&quot;foo1&quot;; &quot;bar2&quot;; &quot;baz3&quot;]</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">f</span> <p>The predicate function on Unicode code points</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>List of non-separator substrings of <code>s</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-index"><a href="#val-index" class="anchor"></a><code><span><span class="keyword">val</span> index : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>index s substr</code> returns the index of the first instance of <code>substr</code> in <code>s</code>, or <code>-1</code> if <code>substr</code> is not present.</p><p>The index is a byte offset (not code point index).</p><p>Examples:</p><ul><li><code>index &quot;chicken&quot; &quot;ken&quot;</code> returns <code>4</code></li><li><code>index &quot;chicken&quot; &quot;dmr&quot;</code> returns <code>-1</code></li><li><code>index &quot;abc&quot; &quot;&quot;</code> returns <code>0</code></li><li><code>index &quot;&quot; &quot;&quot;</code> returns <code>0</code></li><li><code>index &quot;&quot; &quot;a&quot;</code> returns <code>-1</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">substr</span> <p>The substring to search for</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The byte index of the first occurrence, or <code>-1</code> if not found</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-repeat"><a href="#val-repeat" class="anchor"></a><code><span><span class="keyword">val</span> repeat : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>repeat s count</code> returns a new string consisting of <code>count</code> copies of <code>s</code>.</p><p>Raises <code>Invalid_argument</code> if <code>count</code> is negative.</p><p>Examples:</p><ul><li><code>repeat &quot;na&quot; 2</code> returns <code>&quot;nana&quot;</code></li><li><code>repeat &quot;🍎&quot; 3</code> returns <code>&quot;🍎🍎🍎&quot;</code></li><li><code>repeat &quot;&quot; 5</code> returns <code>&quot;&quot;</code></li><li><code>repeat &quot;a&quot; 0</code> returns <code>&quot;&quot;</code></li><li><code>repeat &quot;abc&quot; (-1)</code> raises <code>Invalid_argument</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The string to repeat</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">count</span> <p>The number of times to repeat <code>s</code></p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The repeated string</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-join"><a href="#val-join" class="anchor"></a><code><span><span class="keyword">val</span> join : <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>join elems sep</code> concatenates the elements of <code>elems</code>, inserting <code>sep</code> between each element.</p><p>Returns the empty string if <code>elems</code> is empty.</p><p>Examples:</p><ul><li><code>join [&quot;foo&quot;; &quot;bar&quot;; &quot;baz&quot;] &quot;, &quot;</code> returns <code>&quot;foo, bar, baz&quot;</code></li><li><code>join [] &quot;, &quot;</code> returns <code>&quot;&quot;</code></li><li><code>join [&quot;a&quot;] &quot;, &quot;</code> returns <code>&quot;a&quot;</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">elems</span> <p>The list of strings to join</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">sep</span> <p>The separator string</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The joined string</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trim"><a href="#val-trim" class="anchor"></a><code><span><span class="keyword">val</span> trim : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>trim s cutset</code> returns <code>s</code> with all leading and trailing Unicode code points contained in <code>cutset</code> removed.</p><p>This function is Unicode-aware and trims by code points, not bytes.</p><p>Examples:</p><ul><li><code>trim &quot;¡¡¡Hello, Camels!!!&quot; &quot;!¡&quot;</code> returns <code>&quot;Hello, Camels&quot;</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">cutset</span> <p>The set of Unicode code points to trim (UTF-8)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The trimmed string</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trim_func"><a href="#val-trim_func" class="anchor"></a><code><span><span class="keyword">val</span> trim_func : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Uchar.t <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>trim_func s f</code> returns <code>s</code> with all leading and trailing Unicode code points <code>c</code> satisfying <code>f c</code> removed.</p><p>This function is Unicode-aware and trims by code points, not bytes.</p><p>Examples:</p><ul><li><code>trim_func &quot;¡¡¡Hello, Camels!!!&quot; (fun c -&gt; not (is_letter c || is_number c))</code> returns <code>&quot;Hello, Camels&quot;</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">f</span> <p>The predicate function on Unicode code points</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The trimmed string</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trim_left"><a href="#val-trim_left" class="anchor"></a><code><span><span class="keyword">val</span> trim_left : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>trim_left s cutset</code> returns <code>s</code> with all leading Unicode code points contained in <code>cutset</code> removed.</p><p>This function is Unicode-aware and trims by code points, not bytes.</p><p>Examples:</p><ul><li><code>trim_left &quot;¡¡¡Hello, Camels!!!&quot; &quot;!¡&quot;</code> returns <code>&quot;Hello, Camels!!!&quot;</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">cutset</span> <p>The set of Unicode code points to trim (UTF-8)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The trimmed string</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trim_left_func"><a href="#val-trim_left_func" class="anchor"></a><code><span><span class="keyword">val</span> trim_left_func : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Uchar.t <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>trim_left_func s f</code> returns <code>s</code> with all leading Unicode code points <code>c</code> satisfying <code>f c</code> removed.</p><p>This function is Unicode-aware and trims by code points, not bytes.</p><p>Examples:</p><ul><li><code>trim_left_func &quot;¡¡¡Hello, Camels!!!&quot; (fun c -&gt; not (is_letter c || is_number c))</code> returns <code>&quot;Hello, Camels!!!&quot;</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">f</span> <p>The predicate function on Unicode code points</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The trimmed string</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trim_right"><a href="#val-trim_right" class="anchor"></a><code><span><span class="keyword">val</span> trim_right : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>trim_right s cutset</code> returns <code>s</code> with all trailing Unicode code points contained in <code>cutset</code> removed.</p><p>This function is Unicode-aware and trims by code points, not bytes.</p><p>Examples:</p><ul><li><code>trim_right &quot;¡¡¡Hello, Camels!!!&quot; &quot;!¡&quot;</code> returns <code>&quot;¡¡¡Hello, Camels&quot;</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">cutset</span> <p>The set of Unicode code points to trim (UTF-8)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The trimmed string</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trim_right_func"><a href="#val-trim_right_func" class="anchor"></a><code><span><span class="keyword">val</span> trim_right_func : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Uchar.t <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>trim_right_func s f</code> returns <code>s</code> with all trailing Unicode code points <code>c</code> satisfying <code>f c</code> removed.</p><p>This function is Unicode-aware and trims by code points, not bytes.</p><p>Examples:</p><ul><li><code>trim_right_func &quot;¡¡¡Hello, Camels!!!&quot; (fun c -&gt; not (is_letter c || is_number c))</code> returns <code>&quot;¡¡¡Hello, Camels&quot;</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">f</span> <p>The predicate function on Unicode code points</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The trimmed string</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trim_space"><a href="#val-trim_space" class="anchor"></a><code><span><span class="keyword">val</span> trim_space : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>trim_space s</code> returns <code>s</code> with all leading and trailing Unicode whitespace removed.</p><p>This function is Unicode-aware and trims by code points, not bytes. Whitespace is defined by Unicode (see <code>is_space</code>).</p><p>Examples:</p><ul><li><code>trim_space &quot; \t\n Hello, Camels \n\t\r\n&quot;</code> returns <code>&quot;Hello, Camels&quot;</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The trimmed string</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trim_suffix"><a href="#val-trim_suffix" class="anchor"></a><code><span><span class="keyword">val</span> trim_suffix : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>trim_suffix s suffix</code> returns <code>s</code> without the provided trailing <code>suffix</code> string. If <code>s</code> does not end with <code>suffix</code>, <code>s</code> is returned unchanged.</p><p>This function is byte-based, not Unicode-aware.</p><p>Examples:</p><ul><li><code>trim_suffix &quot;¡¡¡Hello, Camels!!!&quot; &quot;, Camels!!!&quot;</code> returns <code>&quot;¡¡¡Hello&quot;</code></li><li><code>trim_suffix &quot;¡¡¡Hello, Camels!!!&quot; &quot;, Marmots!!!&quot;</code> returns <code>&quot;¡¡¡Hello, Camels!!!&quot;</code></li><li><code>trim_suffix &quot;abc&quot; &quot;&quot;</code> returns <code>&quot;abc&quot;</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">suffix</span> <p>The suffix to remove</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>s</code> without the trailing <code>suffix</code>, or <code>s</code> if <code>suffix</code> is not present</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_lower"><a href="#val-to_lower" class="anchor"></a><code><span><span class="keyword">val</span> to_lower : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_lower s</code> returns <code>s</code> with all Unicode letters mapped to their lower case.</p><p>This function currently only lowercases ASCII letters (A-Z). Unicode-aware lowercasing is not yet implemented.</p><p>Examples:</p><ul><li><code>to_lower &quot;Camel&quot;</code> returns <code>&quot;camel&quot;</code></li><li><code>to_lower &quot;CAMEL&quot;</code> returns <code>&quot;camel&quot;</code></li><li><code>to_lower &quot;こんにちは&quot;</code> returns <code>&quot;こんにちは&quot;</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The lowercased string</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_title"><a href="#val-to_title" class="anchor"></a><code><span><span class="keyword">val</span> to_title : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_title s</code> returns <code>s</code> with all Unicode letters mapped to their Unicode title case.</p><p>Currently, only ASCII letters are supported (A-Z, a-z). TODO: Support full Unicode title case in the future.</p><p>Examples:</p><ul><li><code>to_title &quot;her royal highness&quot;</code> returns <code>&quot;HER ROYAL HIGHNESS&quot;</code></li><li><code>to_title &quot;loud noises&quot;</code> returns <code>&quot;LOUD NOISES&quot;</code></li><li><code>to_title &quot;брат&quot;</code> returns <code>&quot;брат&quot;</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The title-cased string</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_upper"><a href="#val-to_upper" class="anchor"></a><code><span><span class="keyword">val</span> to_upper : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_upper s</code> returns <code>s</code> with all Unicode letters mapped to their upper case.</p><p>This function currently only uppercases ASCII letters (a-z). TODO: Support full Unicode uppercasing in the future.</p><p>Examples:</p><ul><li><code>to_upper &quot;Camel&quot;</code> returns <code>&quot;CAMEL&quot;</code></li><li><code>to_upper &quot;camel&quot;</code> returns <code>&quot;CAMEL&quot;</code></li><li><code>to_upper &quot;こんにちは&quot;</code> returns <code>&quot;こんにちは&quot;</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The uppercased string</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_camel_case"><a href="#val-to_camel_case" class="anchor"></a><code><span><span class="keyword">val</span> to_camel_case : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Convert words separated by space, underscore, or hyphen to camel case.</p><ul><li>Words are split on '_', '-', or space.</li><li>The first word is lowercased (even if originally all uppercase).</li><li>Subsequent words are capitalized (first letter uppercase, rest lowercase).</li><li>All-uppercase words are handled (e.g. &quot;GOLANG_IS_GREAT&quot; → &quot;golangIsGreat&quot;).</li><li>If there are no separators, the original string is returned (e.g. &quot;alreadyCamel&quot; → &quot;alreadyCamel&quot;).</li><li>Leading and trailing underscores are preserved (e.g. &quot;_complex__case_&quot; → &quot;_complexCase_&quot;).</li><li>Multiple consecutive separators are treated as a single word boundary.</li><li>Hyphens and spaces are also treated as word boundaries.</li></ul><p>Examples:</p><ul><li>to_camel_case &quot;some_words&quot; = &quot;someWords&quot;</li><li>to_camel_case &quot;_complex__case_&quot; = &quot;_complexCase_&quot;</li><li>to_camel_case &quot;OCAML_IS_GREAT&quot; = &quot;ocamlIsGreat&quot;</li><li>to_camel_case &quot;alreadyCamel&quot; = &quot;alreadyCamel&quot;</li><li>to_camel_case &quot;foo-BarBaz&quot; = &quot;fooBarBaz&quot;</li><li>to_camel_case &quot;word&quot; = &quot;word&quot;</li><li>to_camel_case &quot;&quot; = &quot;&quot;</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_kebab_case"><a href="#val-to_kebab_case" class="anchor"></a><code><span><span class="keyword">val</span> to_kebab_case : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_kebab_case s</code> converts a string to kebab-case.</p><ul><li>Uppercase ASCII letters are converted to lowercase.</li><li>Word boundaries are detected at transitions from lowercase to uppercase, from letter to digit, and at underscores, spaces, or hyphens.</li><li>All word boundaries are replaced with a single hyphen '-'.</li><li>Multiple consecutive separators are treated as a single hyphen.</li><li>Leading and trailing hyphens are removed.</li><li>If the input is empty, returns the empty string.</li></ul><p>Examples:</p><ul><li>to_kebab_case &quot;FirstName&quot; = &quot;first-name&quot;</li><li>to_kebab_case &quot;HTTPServer&quot; = &quot;http-server&quot;</li><li>to_kebab_case &quot;NoHTTPS&quot; = &quot;no-https&quot;</li><li>to_kebab_case &quot;GO_PATH&quot; = &quot;go-path&quot;</li><li>to_kebab_case &quot;GO PATH&quot; = &quot;go-path&quot;</li><li>to_kebab_case &quot;GO-PATH&quot; = &quot;go-path&quot;</li><li>to_kebab_case &quot;http2xx&quot; = &quot;http-2xx&quot;</li><li>to_kebab_case &quot;HTTP20xOK&quot; = &quot;http-20x-ok&quot;</li><li>to_kebab_case &quot;Duration2m3s&quot; = &quot;duration-2m-3s&quot;</li><li>to_kebab_case &quot;Bld4Floor3rd&quot; = &quot;bld4-floor-3rd&quot;</li><li>to_kebab_case &quot;abc&quot; = &quot;abc&quot;</li><li>to_kebab_case &quot;A&quot; = &quot;a&quot;</li><li>to_kebab_case &quot;FooBarBaz&quot; = &quot;foo-bar-baz&quot;</li><li>to_kebab_case &quot;&quot; = &quot;&quot;</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_pascal_case"><a href="#val-to_pascal_case" class="anchor"></a><code><span><span class="keyword">val</span> to_pascal_case : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Convert words separated by space, underscore, or hyphen to PascalCase.</p><ul><li>Words are split on '_', '-', or space.</li><li>Each word is capitalized (first letter uppercase, rest lowercase).</li><li>All-uppercase words are handled (e.g. &quot;OCAML_IS_GREAT&quot; → &quot;OcamlIsGreat&quot;).</li><li>If there are no separators, the first letter is uppercased, the rest are unchanged.</li><li>Leading and trailing underscores and separators are removed in the output.</li><li>Multiple consecutive separators are treated as a single word boundary.</li><li>Hyphens and spaces are also treated as word boundaries. Examples:</li><li>to_pascal_case &quot;some_words&quot; = &quot;SomeWords&quot;</li><li>to_pascal_case &quot;_complex__case_&quot; = &quot;ComplexCase&quot;</li><li>to_pascal_case &quot;OCAML_IS_GREAT&quot; = &quot;OcamlIsGreat&quot;</li><li>to_pascal_case &quot;alreadyPascal&quot; = &quot;AlreadyPascal&quot;</li><li>to_pascal_case &quot;foo-BarBaz&quot; = &quot;FooBarBaz&quot;</li><li>to_pascal_case &quot;word&quot; = &quot;Word&quot;</li><li>to_pascal_case &quot;&quot; = &quot;&quot;</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_snake_case"><a href="#val-to_snake_case" class="anchor"></a><code><span><span class="keyword">val</span> to_snake_case : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_snake_case s</code> converts a string to snake_case.</p><ul><li>Uppercase ASCII letters are converted to lowercase.</li><li>Word boundaries are detected at transitions from lowercase to uppercase, from letter to digit, and at underscores, spaces, or hyphens.</li><li>All word boundaries are replaced with a single underscore '_'.</li><li>Multiple consecutive separators are treated as a single underscore.</li><li>Leading and trailing underscores are removed.</li><li>If the input is empty, returns the empty string.</li></ul><p>Examples:</p><ul><li>to_snake_case &quot;FirstName&quot; = &quot;first_name&quot;</li><li>to_snake_case &quot;HTTPServer&quot; = &quot;http_server&quot;</li><li>to_snake_case &quot;NoHTTPS&quot; = &quot;no_https&quot;</li><li>to_snake_case &quot;GO_PATH&quot; = &quot;go_path&quot;</li><li>to_snake_case &quot;GO PATH&quot; = &quot;go_path&quot;</li><li>to_snake_case &quot;GO-PATH&quot; = &quot;go_path&quot;</li><li>to_snake_case &quot;http2xx&quot; = &quot;http_2xx&quot;</li><li>to_snake_case &quot;HTTP20xOK&quot; = &quot;http_20x_ok&quot;</li><li>to_snake_case &quot;Duration2m3s&quot; = &quot;duration_2m3s&quot;</li><li>to_snake_case &quot;Bld4Floor3rd&quot; = &quot;bld4_floor_3rd&quot;</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Uchar.t <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Uchar.t)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>map f s</code> returns a new string which is the result of applying <code>f</code> to each Unicode code point of <code>s</code>. The mapping function <code>f</code> must return a valid <code>Uchar.t</code> for every input.</p><p>This function is Unicode-aware: it decodes <code>s</code> into code points, applies <code>f</code>, then re-encodes into UTF-8.</p><p>Example: let rot13 u = let c = Uchar.to_int u in if c &gt;= Char.code 'A' &amp;&amp; c &lt;= Char.code 'Z' then Uchar.of_int (Char.code 'A' + ((c - Char.code 'A' + 13) mod 26)) else if c &gt;= Char.code 'a' &amp;&amp; c &lt;= Char.code 'z' then Uchar.of_int (Char.code 'a' + ((c - Char.code 'a' + 13) mod 26)) else u in map rot13 &quot;'Twas brillig and the slithy camel...&quot; = &quot;'Gjnf oevyyvt naq gur fyvgul pnzry...&quot;</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Uchar.t <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Uchar.t option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>filter_map f s</code> applies <code>f</code> to each Unicode code point <code>u</code> of <code>s</code>. If <code>f u</code> returns <code>Some u'</code>, <code>u'</code> is kept in the result; if <code>None</code>, <code>u</code> is dropped.</p><p>This function is Unicode-aware: it decodes <code>s</code> into code points, applies <code>f</code>, then re-encodes into UTF-8.</p><p>Example: let drop_vowel u = match Uchar.to_int u with | c when List.mem c <code> Char.code 'a'; Char.code 'e'; Char.code 'i' ; Char.code 'o'; Char.code 'u' </code> -&gt; None | _ -&gt; Some u in filter_map drop_vowel &quot;hello&quot; = &quot;hll&quot;</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Uchar.t <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter f s</code> applies <code>f</code> to each Unicode code point of <code>s</code>, in sequence, purely for side-effects.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>(<span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Uchar.t <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span></span></code></div><div class="spec-doc"><p><code>fold f init s</code> applies <code>f acc u</code> to each Unicode code point <code>u</code> of <code>s</code>, carrying along an accumulator <code>acc</code>, and returns the final accumulator.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-expand_tabs"><a href="#val-expand_tabs" class="anchor"></a><code><span><span class="keyword">val</span> expand_tabs : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>expand_tabs s tab_size</code> expands tab characters ('\t') in <code>s</code> to spaces, depending on the current column and <code>tab_size</code>. The column is reset to zero after each newline ('\n'). CJK characters are treated as width 2.</p><p>Raises <code>Invalid_argument</code> if <code>tab_size</code> &lt;= 0.</p><p>Examples:</p><ul><li>expand_tabs &quot;a\tbc\tdef\tghij\tk&quot; 4 = &quot;a bc def ghij k&quot;</li><li>expand_tabs &quot;abcdefg\thij\nk\tl&quot; 4 = &quot;abcdefg hij\nk l&quot;</li><li>expand_tabs &quot;z中\t文\tw&quot; 4 = &quot;z中 文 w&quot;</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-first_rune_to_lower"><a href="#val-first_rune_to_lower" class="anchor"></a><code><span><span class="keyword">val</span> first_rune_to_lower : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>first_rune_to_lower s</code> returns <code>s</code> with the first Unicode code point converted to lower case if it is an uppercase ASCII letter. Unicode-aware: only the first code point is affected, the rest are unchanged.</p><p>Examples:</p><ul><li>first_rune_to_lower &quot;CamelCase&quot; = &quot;camelCase&quot;</li><li>first_rune_to_lower &quot;camelCase&quot; = &quot;camelCase&quot;</li><li>first_rune_to_lower &quot;CAMEL&quot; = &quot;cAMEL&quot;</li><li>first_rune_to_lower &quot;こんにちは&quot; = &quot;こんにちは&quot;</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-first_rune_to_upper"><a href="#val-first_rune_to_upper" class="anchor"></a><code><span><span class="keyword">val</span> first_rune_to_upper : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>first_rune_to_upper s</code> returns <code>s</code> with the first Unicode code point converted to upper case if it is a lowercase ASCII letter. Unicode-aware: only the first code point is affected, the rest are unchanged.</p><p>Examples:</p><ul><li>first_rune_to_upper &quot;camelCase&quot; = &quot;CamelCase&quot;</li><li>first_rune_to_upper &quot;CamelCase&quot; = &quot;CamelCase&quot;</li><li>first_rune_to_upper &quot;camel&quot; = &quot;Camel&quot;</li><li>first_rune_to_upper &quot;こんにちは&quot; = &quot;こんにちは&quot;</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-insert"><a href="#val-insert" class="anchor"></a><code><span><span class="keyword">val</span> insert : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>insert dst src index</code> inserts <code>src</code> into <code>dst</code> at the given Unicode code point index. Index is counted by code points (runes), not bytes. Raises <code>Invalid_argument</code> if <code>index</code> is out of range (index &lt; 0 or index &gt; length of <code>dst</code>).</p><p>Examples:</p><ul><li>insert &quot;CamelCase&quot; &quot;Super&quot; 5 = &quot;CamelSuperCase&quot;</li><li>insert &quot;こんにちは&quot; &quot;世界&quot; 2 = &quot;こん世界にちは&quot;</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-last_partition"><a href="#val-last_partition" class="anchor"></a><code><span><span class="keyword">val</span> last_partition : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string * string * string</span></code></div><div class="spec-doc"><p><code>last_partition str sep</code> splits <code>str</code> by the last instance of <code>sep</code> into three parts: (<code>head</code>, <code>match</code>, <code>tail</code>). If <code>sep</code> is found, <code>head</code> is the part before the last <code>sep</code>, <code>match</code> is <code>sep</code>, and <code>tail</code> is the part after. If <code>sep</code> is not found, returns (&quot;&quot;, &quot;&quot;, <code>str</code>). Operates on bytes, not code points.</p><p>Examples:</p><ul><li>last_partition &quot;hello&quot; &quot;l&quot; = (&quot;hel&quot;, &quot;l&quot;, &quot;o&quot;)</li><li>last_partition &quot;hello&quot; &quot;x&quot; = (&quot;&quot;, &quot;&quot;, &quot;hello&quot;)</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-left_justify"><a href="#val-left_justify" class="anchor"></a><code><span><span class="keyword">val</span> left_justify : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>left_justify s width pad</code> returns <code>s</code> left-justified in a string of <code>width</code> Unicode code points, padding with <code>pad</code> on the right if needed. If <code>s</code> is longer than <code>width</code>, it is returned unchanged. If <code>pad</code> is empty, <code>s</code> is returned unchanged. Padding is truncated as needed. Unicode-aware: counts code points, not bytes.</p><p>Examples:</p><ul><li>left_justify &quot;hello&quot; 4 &quot; &quot; = &quot;hello&quot;</li><li>left_justify &quot;hello&quot; 10 &quot; &quot; = &quot;hello &quot;</li><li>left_justify &quot;hello&quot; 10 &quot;123&quot; = &quot;hello12312&quot;</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span><span class="keyword">val</span> partition : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string * string * string</span></code></div><div class="spec-doc"><p><code>partition str sep</code> splits <code>str</code> by the first instance of <code>sep</code> into three parts: (<code>head</code>, <code>match</code>, <code>tail</code>). If <code>sep</code> is found, <code>head</code> is the part before the first <code>sep</code>, <code>match</code> is <code>sep</code>, and <code>tail</code> is the part after. If <code>sep</code> is not found, returns (<code>str</code>, &quot;&quot;, &quot;&quot;). Operates on bytes, not code points.</p><p>Examples:</p><ul><li>partition &quot;hello&quot; &quot;l&quot; = (&quot;he&quot;, &quot;l&quot;, &quot;lo&quot;)</li><li>partition &quot;hello&quot; &quot;x&quot; = (&quot;hello&quot;, &quot;&quot;, &quot;&quot;)</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-right_justify"><a href="#val-right_justify" class="anchor"></a><code><span><span class="keyword">val</span> right_justify : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>right_justify s width pad</code> returns <code>s</code> right-justified in a string of <code>width</code> Unicode code points, padding with <code>pad</code> on the left if needed. If <code>s</code> is longer than <code>width</code>, it is returned unchanged. If <code>pad</code> is empty, <code>s</code> is returned unchanged. Padding is truncated as needed. Unicode-aware: counts code points, not bytes.</p><p>Examples:</p><ul><li>right_justify &quot;hello&quot; 4 &quot; &quot; = &quot;hello&quot;</li><li>right_justify &quot;hello&quot; 10 &quot; &quot; = &quot; hello&quot;</li><li>right_justify &quot;hello&quot; 10 &quot;123&quot; = &quot;12312hello&quot;</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rune_width"><a href="#val-rune_width" class="anchor"></a><code><span><span class="keyword">val</span> rune_width : <span><span class="xref-unresolved">Stdlib</span>.Uchar.t <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>rune_width u</code> returns the character width of Unicode code point <code>u</code> in a monotype font. Multi-byte (East Asian wide) characters are usually twice the width of single byte characters.</p><p>The algorithm is based on PHP's mb_strwidth. See: http://php.net/manual/en/function.mb-strwidth.php</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">u</span> <p>The Unicode code point</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The width (1 or 2)</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-scrub"><a href="#val-scrub" class="anchor"></a><code><span><span class="keyword">val</span> scrub : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>scrub str repl</code> replaces invalid UTF-8 byte sequences in <code>str</code> with <code>repl</code>. Adjacent invalid bytes are replaced only once. Unicode-aware.</p><p>Examples:</p><ul><li><code>scrub &quot;a\xffb&quot; &quot;?&quot;</code> returns <code>&quot;a?b&quot;</code></li><li><code>scrub &quot;a\xff\xffb&quot; &quot;?&quot;</code> returns <code>&quot;a?b&quot;</code></li><li><code>scrub &quot;a\xffb\xff&quot; &quot;?&quot;</code> returns <code>&quot;a?b?&quot;</code></li><li><code>scrub &quot;abc&quot; &quot;?&quot;</code> returns <code>&quot;abc&quot;</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">str</span> <p>The input string (possibly invalid UTF-8)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">repl</span> <p>The replacement string for invalid bytes</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The scrubbed string</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shuffle"><a href="#val-shuffle" class="anchor"></a><code><span><span class="keyword">val</span> shuffle : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>shuffle str</code> randomizes the order of Unicode code points in <code>str</code> and returns the result. Uses OCaml's Random module as the random source. This is equivalent to PHP's str_shuffle. Unicode-aware: shuffles by code points, not bytes.</p><p>Examples:</p><ul><li><code>shuffle &quot;Camel&quot;</code> might return <code>&quot;eCaml&quot;</code>, <code>&quot;lCema&quot;</code>, etc.</li><li><code>shuffle &quot;こんにちは&quot;</code> might return <code>&quot;にちこんは&quot;</code>, etc.</li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">str</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The shuffled string</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shuffle_source"><a href="#val-shuffle_source" class="anchor"></a><code><span><span class="keyword">val</span> shuffle_source : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Random.State.t <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>shuffle_source str rand_state</code> randomizes the order of Unicode code points in <code>str</code> using the given <code>Random.State.t</code> as the random source. This is equivalent to PHP's str_shuffle. Unicode-aware: shuffles by code points, not bytes.</p><p>Examples:</p><ul><li><code>shuffle_source &quot;Camel&quot; (Random.State.make [|42|])</code> might return <code>&quot;eCaml&quot;</code>, <code>&quot;lCema&quot;</code>, etc.</li><li><code>shuffle_source &quot;こんにちは&quot; (Random.State.make [|42|])</code> might return <code>&quot;にちこんは&quot;</code>, etc.</li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">str</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rand_state</span> <p>The random state to use for shuffling</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The shuffled string</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-slice"><a href="#val-slice" class="anchor"></a><code><span><span class="keyword">val</span> slice : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>slice str start end_</code> returns the substring of <code>str</code> from code point index <code>start</code> (inclusive) to <code>end_</code> (exclusive). Indexing is by Unicode code points, not bytes.</p><ul><li><code>start</code> must satisfy 0 &lt;= start &lt;= rune length.</li><li><code>end_</code> can be positive, zero, or negative.</li><li>If <code>end_</code> &gt;= 0, then start &lt;= end_ &lt;= rune length.</li><li>If <code>end_</code> &lt; 0, it means slice to the end of string.</li></ul><p>Raises <code>Invalid_argument</code> if indices are out of range.</p><p>This is equivalent to PHP's mb_substr.</p><p>Examples:</p><ul><li><code>slice &quot;CamelCase&quot; 0 5</code> returns <code>&quot;Camel&quot;</code></li><li><code>slice &quot;CamelCase&quot; 5 (-1)</code> returns <code>&quot;Case&quot;</code></li><li><code>slice &quot;こんにちは&quot; 2 4</code> returns <code>&quot;にち&quot;</code></li><li><code>slice &quot;こんにちは&quot; 2 (-1)</code> returns <code>&quot;にちは&quot;</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">str</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">start</span> <p>The start code point index (inclusive)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">end_</span> <p>The end code point index (exclusive), or negative for end of string</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The sliced substring</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-squeeze"><a href="#val-squeeze" class="anchor"></a><code><span><span class="keyword">val</span> squeeze : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>squeeze str pattern</code> deletes adjacent repeated Unicode code points in <code>str</code>. If <code>pattern</code> is not empty, only code points matching <code>pattern</code> are squeezed. Unicode-aware: operates on code points, not bytes.</p><p>This is equivalent to Ruby's String#squeeze.</p><p>Examples:</p><ul><li><code>squeeze &quot;hello&quot; &quot;&quot;</code> returns <code>&quot;helo&quot;</code></li><li><code>squeeze &quot;hello&quot; &quot;m-z&quot;</code> returns <code>&quot;hello&quot;</code></li><li><code>squeeze &quot;hello   world&quot; &quot; &quot;</code> returns <code>&quot;hello world&quot;</code></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">str</span> <p>The input string (UTF-8)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pattern</span> <p>The pattern of code points to squeeze (UTF-8, can be empty)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The squeezed string</p></li></ul></div></div></div></body></html>
